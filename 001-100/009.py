'''
回文数
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例1
输入: 121
输出: true

示例 2
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。

进阶:
你能不将整数转为字符串来解决这个问题吗？
https://leetcode-cn.com/problems/palindrome-number/

#解题思路：
1.先判断x传进来的两种情况:

是否为负数
数字最后一位是否为0(除了0本身) 以上两种情况反转后肯定不等于原来的数,因此要先过滤掉
2.根据题目要求要返回与输入结果是否相等,因此与第七题反转数字的思路是一样的,但是有一点小小的区别,可以只计算一半就返回判断结果,因为根据回文对称原则,前半部分与后半部分一定是相等的,比如:

x=12321,reverse=0,使用栈推出的方法,推出倒数第一个和第二个数字后reverse为12,x为123,而在x长度为奇数的情况下中间的数字是可以忽略掉的,因此可以设定一个当x>reverse的循环条件,当reverse变为123后退出循环
判断是否相等的时候,根据上文提到的奇数情况下3是可以忽略掉的,因此可以用reverse/10把3删除掉后与x进行比较
需要注意的是在反转的过程中不需要判断是否溢出,假设传入数字为123456789,完全反转后的数字为987654321,假设这个数字是溢出的,那么反转到一半的时候reverse=98765,只反转了一半的长度,也不会存在溢出的问题,即使给出的x完整反转后是存在溢出,由于题目没有明确说明这种情况下这里暂不对这种情况做讨论
'''

def isPalindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reverse = 0
    while x > reverse:
        reverse = reverse * 10 + x % 10
        x = x // 10
    return x == reverse or x == reverse // 10

print(isPalindrome(121))
print(isPalindrome(-121))
print(isPalindrome(-123))
print(isPalindrome(10))
print(isPalindrome(1234567899))